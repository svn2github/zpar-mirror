\documentclass[12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{CJK}
\usepackage{times}
\makeindex
\title{Introduction to the ZPar build system~(ZPar 0.7 and above)}
\begin{document}
\begin{CJK}{GBK}{song}
\maketitle

\section{Overview}
\label{sec:overview}
ZPar is built using the \href{http://www.gnu.org/software/make/}{make} build system
by providing a set of predefined rules and compilation actions.
You may easily customize ZPar or contribute third-party code
by adapting the Makefiles.

\section{How to compile ZPar}
Suppose that ZPar has been downloaded to the directory \textit{zpar}. 
To make a POS tagging system for English, 
type \textit{make english.postagger}. 
This will create a directory \textit{zpar/dist/english.postagger}, 
in which there are two files: \textit{train} and \textit{tagger}. 
The file \textit{train} is used to train a tagging model,
and the file \textit{tagger} is used to tag new texts using a trained parsing model.
\\
\\
Parsers and POS taggers for other languages can be built in similar ways,
please refer to specific manuals for detailed instructions.

\section{How to change implementations}
\label{sec:how-change-impl}

ZPar provides various implementations for parsers and POS taggers for all the supported languages.
To change the implementations, simply edit the different \texttt{*\_IMPL} macro in \textit{zpar/Makefile}.
For example, to use TWeb as POS tagger for generic language, just make the following change to the \textit{zpar/Makefile}:
\\
\\
\hspace{3cm}\texttt{GENERIC\_TAGGER\_IMPL = tweb}
\\
\\
Then build the generic POS tagger as usual.
\\
\\
To examine which implementations are supported for a specific task,
please consult the sub-folders under:
\\
\\
\texttt{zpar/src/\textit{<LANGUAGE>}/\textit{<TASK>}/implementations/}
\\
\\
The name of the sub-folder is also the name of the implementation.
The \texttt{\textit{<LANGUAGE>}} can be:
\begin{itemize}
\item \texttt{\textit{chinese}}: for Chinese only;
\item \texttt{\textit{english}}: for English only;
\item \texttt{\textit{spanish}}: for Spanish only;
\item \texttt{\textit{common}}: for all of Chinese, English, Spanish and geniric languages.
\end{itemize}
The \texttt{\textit{<TASK>}}can be:
\begin{itemize}
\item \texttt{\textit{tagger}}: for POS tagging;
\item \texttt{\textit{conparser}}: for constituency parsing;
\item \texttt{\textit{depparser}}: for dependency parsing;
\item \texttt{\textit{deplabeler}}: for dependency labeling;
\item \texttt{\textit{segmentor}}: for word segmentation, Chinese only.
\end{itemize}

\section{How to contribute code}
\label{sec:customizing-zpar}

You may add a new implementation for a specific task
by creating a sub-folder as described in Section~\nameref{sec:how-change-impl}.
\\
\\
ZPar requires all the implementations compatible with
ZPar APIs and source/object file naming conventions.
For example, for a new generic language POS tagger,
the implementation must provide
such a class in source file \texttt{tagger.h} and \texttt{tagger.cpp}:
\begin{verbatim}
namespace TARGET_LANGUAGE {
  class CTagger {
    public:
    CTagger(const std::string &sFeatureDBPath, bool bTrain=false);
    void loadTagDictionary(const std::string &sTagDictPath);
    void loadKnowledge(const std::string &sKnowledge);
    bool train(const CTwoStringVector *correct);
    void finishTraining();
    void tag(CStringVector *sentence, CTwoStringVector *retval, int nBest=1, double *out_scores=NULL);
  }
}
\end{verbatim}
and \texttt{tagger.cpp} should be compiled into \texttt{generic.postagger.o}.
Furthermore, a POS tagger implementation should provide
\texttt{tagger\_weight.h}, \texttt{tagger\_weight.cpp}
which should be compiled into \texttt{weight.o}.
For other tasks and languages, you may look into an existing implementations
and Makefile template for details.
\\
\\
If the custom implementation can be contained 
in those source and object files,
there's nothing special to do.
Simple change the different \texttt{*\_IMPL} macro in \textit{zpar/Makefile}
into the name of the custom implementation and build as usual.
The build system will automatically detect the implementation,
compile it and link it into ZPar.
\\
\\
However, if it isn't sufficient to accomplish
the custom implementation in those files,
you have to provide your own rules and actions
to compile and link the additional objects.
In such situation, make a copy the corresponding Makefile template
for the task and language 
from \textit{zpar/Makefile.d/} folder
to your custom implementation folder:
\\
\\
\hspace{3cm}\texttt{cp Makefile.d/Makefile.\textit{<LANGUAGE>}.\textit{<TASK>} \textbackslash \\
\hspace{3cm}\quad src/\textit{<LANGUAGE>}/\textit{<TASK>}/implementations/\textit{<IMPL\_NAME>}/Makefile}
\\
\\
And change the rules in it to compile the custom implementation.
Note that the object file naming must strictly follow
the conventions described above.
You should link all the required objects of your own into one with proper name.
For details, \textit{zpar/Makefile.d/Makefile.ge.postagger.tweb} can be taken as an example.

\end{CJK}
\end{document}
